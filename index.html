<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework</title>
    <link rel = "stylesheet" href = "css/base.css">
    <link rel = "stylesheet" href = "css/index.css">
</head>
<body>
    <!-- 头部 -->
    <div class = "header" >
        <div class = "wrapper">
            <!--导航-->
            <div class = "nav">
                <ul>
                    <li><a href = "#"  >首页</a></li>
                    <li><a href = "#"  >个人信息</a></li>
                </ul>
            </div>
            <!--搜索-->
            <div class = "search">
                <input type = "text" placeholder = "请输入关键字">
                <a href = "#"></a>
            </div>
            <!--用户-->
            <div class = "user">
                <a href = "#">
                    <span>202212303073廖燕燕</span>
                </a>
            </div>
        </div>
    </div>
    <!-- 首页 -->
    <div class = "homepage" >
        <div class = "banner">
            <div class = "left">
                <ul>
                    <li><a href="#"  >第一章</a></li>
                    <li><a href="#" class = "A">第二章</a></li>
                    <li><a href="#">第三章</a></li>
                    <li><a href="#">第四章</a></li>
                    <li><a href="#">第五章</a></li>
                    <li><a href="#">第六章</a></li>
                    <li><a href="#">第七章</a></li>
                    <li><a href="#">第八章</a></li>
                    <li><a href="#">第九章</a></li>
                    <li><a href="#">第十章</a></li>
                  </ul>
            </div>
            <div class = "welcome">
                <p>
                    <h1>2. servlet的体系结构是怎样的？</h1>
                    servlet技术的核心是servlet，它是所有Servlet类必须直接或间接实现的一个接口。Servlet接口定义了Servlet和Servlet容器之间的契约，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法，用户请求致使Servlet容器调用Servlet的Service方法，传入一个ServletRequest实例和一个ServletResponse实例。ServletRequest封装了当前的合同http请求。ServletResponse则表示当前用户的http响应，使得将响应发送给用户变得十分容易。<br>
                    Servlet是一个接口，在Java EE API中，我们可以看到有一个抽象类GenericServlet实现了Servlet接口，在抽象类GenericServlet又有一个抽象类HttpServlet类继承了它。<br>
                    GenericServlet帮我们把Servlet接口中的init、getServetConfig、getServetInfo、destory这四个方法做了空实现，只留了一个抽象类service。继承这个类，可以使代码更简洁，开发也会更高效。<br>
                    在service方法中，一般都要获取从浏览器发来的数据，这时候我们就要判断http用的是哪种请求方式了。<br>
                    <h1>9.什么是异步Servlet?</h1>
                    在Servlet3.0之前，Servlet采用Thread-per-Request的方式处理请求，即每一次HTTP请求都由某一个线程从头到尾处理。如果一个请求需要进行IO操作，如访问数据库，调用第三方服务接口等，那么其所对应的线程将同步地等待IO完成操作，而IO操作是非常慢的，所以此时地线程并不能及时地释放回线程池以供后续使用，在并发量越来越大地情况下，这将带来严重地性能问题。即便是像Spring、Struts这样地高层框架也脱离不了这样地桎梏，因为他们都是建立在Servlet之上的。为了解决这样的问题，Servlet3.0引入了异步处理。在Servlet3.0中，可以从httpServletRequest对象中获得一个AsyncContext对象，概对象构成了异步处理的上下文，在request和response对象都可直接获取。AsyncContext可以从当前线程传给其它线程，在新的线程中完成对请求的处理并返回结果给客户端，初始线程便可以返回给容器线程池以便处理更多的请求。如此，，通过将请求从一个线程传给另一个线程处理的过程便构成了Servlet3.0中的异步处理。</p>
                    <h1>10.servlet处理http请求的流程是什么？</h1>
	在Servlet3.0之前，Servlet采用Thread-per-Request的方式处理请求，即每一次HTTP请求都由某一个线程从头到尾处理。如果一个请求需要进行IO操作，如访问数据库，调用第三方服务接口等，那么其所对应的线程将同步地等待IO完成操作，而IO操作是非常慢的，所以此时地线程并不能及时地释放回线程池以供后续使用，在并发量越来越大地情况下，这将带来严重地性能问题。即便是像Spring、Struts这样地高层框架也脱离不了这样地桎梏，因为他们都是建立在Servlet之上的。为了解决这样的问题，Servlet3.0引入了异步处理。在Servlet3.0中，可以从httpServletRequest对象中获得一个AsyncContext对象，概对象构成了异步处理的上下文，在request和response对象都可直接获取。AsyncContext可以从当前线程传给其它线程，在新的线程中完成对请求的处理并返回结果给客户端，初始线程便可以返回给容器线程池以便处理更多的请求。如此，，通过将请求从一个线程传给另一个线程处理的过程便构成了Servlet3.0中的异步处理。
	<br>
	(1)浏览器从地址栏中获取主机名,并获取主机名对应的ip地址，首先从windowshosts文件中查找是否有该主机对应的ip地址 ，如果没有，则查找dns服务器查找主机名对应的ip地址. <br>
	(2).浏览器连接服务器 。<br>
 (3)浏览器向服务器发送http请求。 
 (4).服务器读取请求消息。从请求消息中确定客户机要访问的主机名 。<br>
 (5).务器从请求消息中确定客户机要访问具体的web应用 <br>
 (6).服务器从请求消息中确定客户机要访问具体的web资源 <br>
 (7)服务器发现客户机访问的是一个servlet程序。 <br>
 (8).servlet引擎将客户端请求封装到request对象中,并创建一个响应头和响应体都为空的响应对象response。servlet引擎将这两个对象作为参数传递给service（HttpServletRequest request,HttpServletResponse response）方法.每一个客户端请求访问一次servlet程序， servlet引擎就创建一个对应的request对象和response对象。response对象用于存放servlet程序针对客户端请求产生的数据（响应），以及服务器端控制浏览器显示的响应头。 <br>
 (9).调用业务逻辑service方法对请求进行处理，将response响应返回到服务器程序中。 <br>
 (10).服务器程序检查response对象中是否有数据，如果有，就生成http响应. <br>
 (11).服务器将http响应发送给客户端 <br>
 (12).客户端浏览器显示服务器程序发送的http响应信息.<br>
 <h1>11.Servlet如何处理HTTP请求？</h1>
 HTTPServletResponse接口继承自ServletRespnse接口，专门用来封装HTTP响应消息。由于HTTP响应消息分为状态行、消息响应头、消息体三部分，于是在httpServletResponse接口中也相应定义了向客户端发送响应状态码、响应消息头、响应消息体的方法。
 <h1>12.RequestDispactchar接口的forward（）方法与include（）方法的区别是什么？</h1>
	forward（）：表示在服务端从一个Servlet中将请求转发到另一个资源，本意是让第一个组件对请求做出预处理，而让另一组件处理并返回响应。
include（）：表示在响应中包含另一个资源的响应内容，最终被包含的页面产生的任何响应都将并入原来的response对象，然后一起输出到客户端。
	
                </p>

            </div>
        </div>
    </div>
</body>
</html>